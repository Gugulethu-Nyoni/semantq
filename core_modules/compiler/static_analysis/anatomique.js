import { writeFile, mkdir } from 'node:fs/promises';
import { join, basename } from 'node:path';
import escodegen from 'escodegen';
import { parse } from 'acorn';
import * as estraverse from 'estraverse'; // Import estraverse

// Helper for deep cloning an AST node (needed because we'll modify it)
function deepCloneAstNode(node) {
    // A simple JSON parse/stringify is usually sufficient for most ASTs
    // generated by Acorn, as long as they don't contain circular references
    // or non-JSON-serializable properties (like functions).
    return JSON.parse(JSON.stringify(node));
}

// Recursive AST transformation function
// This function will walk the AST and replace any reactive variable identifier
// with a MemberExpression that accesses its `.value` property.
function transformReactiveIdentifiersInExpression(node, isReactiveVariableFn) {
    if (!node || typeof node !== 'object' || !node.type) {
        return node;
    }

    if (node.type === 'TemplateLiteral') {
        console.log('Processing template literal:', escodegen.generate(node));
    }

    // Process the current node
    if (node.type === 'Identifier' && isReactiveVariableFn(node.name)) {
        // If this identifier is a reactive variable, transform it to `identifier.value`
        // Ensure it's not already part of a '.value' access (though unlikely if it's a bare Identifier)
        return {
            type: 'MemberExpression',
            object: deepCloneAstNode(node), // The original identifier becomes the object
            property: { type: 'Identifier', name: 'value' },
            computed: false,
            optional: false
        };
    }

    // Recursively process children of the current node
    for (const key in node) {
        if (node.hasOwnProperty(key) && key !== 'loc' && key !== 'range' && key !== 'comments' && key !== 'tokens') {
            const value = node[key];
            if (Array.isArray(value)) {
                node[key] = value.map(item => transformReactiveIdentifiersInExpression(item, isReactiveVariableFn));
            } else if (typeof value === 'object' && value !== null) {
                node[key] = transformReactiveIdentifiersInExpression(value, isReactiveVariableFn);
            }
        }
    }
    return node;
}


export default class Anatomique {
    constructor(jsAST, cssAST, customAST, filePath, mainPageOriginalJS = null) {
        this.filePath = filePath;
        //this.mainPageOriginalJS = mainPageOriginalJS;
        this.fileName = basename(filePath, '.ast');
        this.appRootId = 'app';
        this.jsAST = jsAST;
        this.cssAST = cssAST;
        this.customAST = customAST;
        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.transpiledHTML = '';
        this.distDir = './dist';
        this.addState = true;


        this.reactiveVariables = new Set();
        this.staticVariables = new Set();
        this.onMountCallbacks = [];
        this.mainPageOriginalJS = '';
        this.derivedDeclarations = [];





        this.globalDerivedCache = new Map(); // Map: expressionString -> varName
        this.globalDerivedDeclarations = []; // Array of actual 'const varName = $derived(...);' strings

        this.localDerivedDeclarations = null; // A temporary array for block-local deriveds


        //this.analyzeJsAST(); // Populate `this.reactiveVariables` and `this.staticVariables`
        this.analyzeAndFilterJsAST();


        
        this.nodeToTranspilerMap = {
            Element: this.Element.bind(this),
            KeyValueAttribute: this.Attribute.bind(this),
            BooleanAttribute: this.Attribute.bind(this),
            EventHandler: this.Attribute.bind(this),
            TwoWayBindingAttribute: this.Attribute.bind(this),
            MustacheAttribute: this.Attribute.bind(this),
            BooleanIdentifierAttribute: this.Attribute.bind(this),
            Fragment: this.Fragment.bind(this),
            TextNode: this.TextNode.bind(this),
            MustacheTag: this.MustacheTag.bind(this),
            IfStatement: this.IfStatement.bind(this),
            EachStatement: this.EachStatement.bind(this),
            RawHTMLBlock: this.RawHTMLBlock.bind(this)

        };

        //this.transpiledJSContent.push(`const appRoot = document.getElementById('${this.appRootId}');\n`);

        this.traverse();

        //this.output();
    }

    // --- Utility Methods ---

   analyzeNode(astNode) {
        if (!astNode) return;
        estraverse.traverse(astNode, {
            enter: (node) => {
                if (node.type === 'VariableDeclarator') {
                    const varName = node.id.name;
                    if (node.init?.type === 'CallExpression') {
                        const calleeName = node.init.callee?.name;
                        if (calleeName === '$state' || calleeName === '$derived' || calleeName === '$props') {
                            this.reactiveVariables.add(varName);
                            this.staticVariables.delete(varName);
                        } else {
                            if (!this.reactiveVariables.has(varName)) {
                                this.staticVariables.add(varName);
                            }
                        }
                    } else if (node.id.type === 'Identifier') {
                        if (!this.reactiveVariables.has(varName)) {
                            this.staticVariables.add(varName);
                        }
                    }
                }
            }
        });
    }


    analyzeAndFilterJsAST() {
    if (!this.jsAST || !this.jsAST.content) return;

    this.onMountCallbacks = [];
    const topLevelNodesToKeep = [];

    this.jsAST.content.body.forEach(node => {
        if (node.type === 'ImportDeclaration') {
            return;
        }
        
        if (node.type === 'ExpressionStatement' &&
            node.expression?.type === 'CallExpression' &&
            node.expression.callee?.name === '$onMount') {
            this.onMountCallbacks.push(node);
            return;
        }
        
        topLevelNodesToKeep.push(node);
    });

    estraverse.traverse({ type: 'Program', body: topLevelNodesToKeep }, {
        enter: (node, parent) => {
            if (node.type === 'VariableDeclarator') {
                const varName = node.id.name;
                if (node.init?.type === 'CallExpression') {
                    const calleeName = node.init.callee?.name;
                    if (['$state', '$derived', '$props'].includes(calleeName)) {
                        this.reactiveVariables.add(varName);
                        this.staticVariables.delete(varName);
                    }
                }
            }
        },
    });

    this.jsAST.content.body = topLevelNodesToKeep;
    this.mainPageOriginalJS = escodegen.generate(this.jsAST.content);
}

    analyzeJsAST() {
        if (!this.jsAST || !this.jsAST.content) {
            return;
        }

        const filteredBody = [];
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                // If it's a top-level VariableDeclaration, analyze it immediately
                if (parent?.type === 'Program' && node.type === 'VariableDeclaration') {
                    this.analyzeNode(node);
                    filteredBody.push(node);
                    return estraverse.VisitorOption.Skip; // Skip traversal of its children
                }

                // Logic to identify and extract $onMount calls
                if (node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount') {
                    const onMountFunction = node.expression.arguments[0];
                    if (onMountFunction && (onMountFunction.type === 'ArrowFunctionExpression' || onMountFunction.type === 'FunctionExpression')) {
                        const functionBody = onMountFunction.body;

                        // NEW: Analyze the variables inside the onMount block
                        this.analyzeNode(functionBody);

                        // Store the function body as a single BlockStatement node
                        if (functionBody.type === 'BlockStatement') {
                            this.onMountCallbacks.push(...functionBody.body);
                        } else {
                            this.onMountCallbacks.push(functionBody);
                        }
                    }
                    // Skip this node so it doesn't get added to the filteredBody
                    return estraverse.VisitorOption.Skip;
                }
            },
            leave: (node, parent) => {
                // Only push nodes to filteredBody if they are top-level and haven't been skipped
                if (parent?.type === 'Program' && !node.onMountHandled) {
                    filteredBody.push(node);
                }
            }
        });

        this.jsAST.content.body = filteredBody;
        //console.log("REACTIVE VARS", this.reactiveVariables);
        //console.log("STATIC VARS", this.staticVariables);
        //console.log("onMountCallbacks", JSON.stringify(this.onMountCallbacks,null,2));
    }


     // NEW: Method to generate the filtered JS string
    generateMainPageOriginalJS() {
        if (!this.jsAST || !this.jsAST.content) {
            this.mainPageOriginalJS = '';
            return;
        }

        // Create a deep clone to avoid modifying the original AST
        const clonedAST = deepCloneAstNode(this.jsAST.content);

        // Filter out the onMount calls from the AST
        const nonOnMountAST = estraverse.replace(clonedAST, {
            enter(node) {
                if (node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount') {
                    // Remove the node by returning null
                    return this.remove();
                }
            }
        });

        // Generate the code string from the filtered AST
        this.mainPageOriginalJS = escodegen.generate(nonOnMountAST);
    }



    isReactiveVariable(varName) {
        return this.reactiveVariables.has(varName);
    }

    isFunction(varName) {
    const varDecl = this.findVariableDeclaration(varName);
    if (!varDecl) return false;
}

    getUniqueId(prefix = '') {
        return `${prefix}${Math.random().toString(36).slice(2, 8)}`;
    }

    // --- Helper to get/create a derived variable ---
    getOrCreateDerived(expressionCode, context = {}) {
        // If the expression contains a loop variable, we must generate a new derived
        // every time and cannot use the global cache.
        const isLoopItemInExpression = context.itemVar && expressionCode.includes(context.itemVar);
        const isGlobalScope = !this.localDerivedDeclarations;

        if (isGlobalScope && !isLoopItemInExpression && this.globalDerivedCache.has(expressionCode)) {
            return this.globalDerivedCache.get(expressionCode);
        }

        let transformedExpressionCode;
        try {
            // Parse the expression into its own mini-AST
            // Add debug log for parsing derived expressions
            //console.log(`DEBUG: getOrCreateDerived - Parsing expression: (${expressionCode})`);
            const parsedProgram = parse(`(${expressionCode})`, { ecmaVersion: 2020 });
            const expressionAst = parsedProgram.body[0].expression;
            // Apply the transformation using our `isReactiveVariable` checker
            const transformedAst = transformReactiveIdentifiersInExpression(expressionAst, (name) => this.isReactiveVariable(name));
            transformedExpressionCode = escodegen.generate(transformedAst);
        } catch (e) {
            console.error(`Error parsing or transforming derived expression "${expressionCode}":`, e);
            transformedExpressionCode = expressionCode; // Fallback to original code
        }

        const derivedVarName = this.getUniqueId('derived_');
        const derivedDeclaration = `const ${derivedVarName} = $derived(() => ${transformedExpressionCode});`;

        if (isGlobalScope) {
            this.globalDerivedCache.set(expressionCode, derivedVarName);
            this.globalDerivedDeclarations.push(derivedDeclaration);
        } else {
            // Store in the local block's declarations
            this.localDerivedDeclarations.push(derivedDeclaration);
        }

        return derivedVarName;
    }


    // --- Traversal Method ---
            traverse() {
            // The AST is now just the Fragment node.
            // Assign the AST directly to the variable.
            const htmlFragment = this.customAST;

            // We can now access the children directly from the htmlFragment.
            if (!htmlFragment || !Array.isArray(htmlFragment.children)) {
                console.warn("AST fragment or its children not found or not an array. No HTML to transpile.");
                return;
            }

            // Now, find the 'customSyntax' node within the fragment's children.
            const customSyntaxNode = htmlFragment.children.find(
                child => child.type === 'Element' && child.name === 'customSyntax'
            );

            if (!customSyntaxNode) {
                console.error("Custom syntax wrapper element 'customSyntax' not found. Cannot transpile HTML.");
                return;
            }

            if (!Array.isArray(customSyntaxNode.children)) {
                console.error("Custom syntax wrapper element 'customSyntax' has no children or children is not an array. Cannot transpile.");
                return;
            }

           // console.log("DEBUG: traverse - Found 'customSyntax' element with children. Starting transpilation block.");
            
            // Now you can traverse the children of the customSyntax node.
            this.transpileBlock(customSyntaxNode.children, { parentVar: 'appRoot' });
        }



    transpileBlock(blockNodes, context) {
        // --- FIX: Ensure blockNodes is iterable ---
        // This is the primary fix for `TypeError: blockNodes is not iterable`.
        // If blockNodes is null/undefined/not an array, it defaults to an empty array.
        const nodesToTranspile = Array.isArray(blockNodes) ? blockNodes : [];

        // Add debug log for transpileBlock
        ////console.log(`DEBUG: transpileBlock - Processing ${nodesToTranspile.length} nodes for parent: ${context.parentVar}`);

        for (const child of nodesToTranspile) {
            // Skip comments
            if (child.type === 'CommentBlock') {
                ////console.log(`DEBUG: transpileBlock - Skipping CommentBlock.`);
                continue;
            }

            const transpileFn = this.nodeToTranspilerMap[child.type];
            if (transpileFn) {
                ////console.log(`DEBUG: transpileBlock - Transpiling node type: ${child.type}`);
                transpileFn(child, context.parentVar, context);
            } else {
                console.warn(`No transpiler function found for node type: ${child.type} within a block. Node:`, child);
            }
        }
    }


    // --- Node Transpilation Methods ---

    Element(node, parentVar, context = {}) {
    const varName = `${node.name}_elem_${this.getUniqueId()}`;
    
    // Check if the element is a <pre> or <code> tag
    if (node.name === 'pre' || node.name === 'code') {
        const rawContent = this.preserveRawContent(node.children);
        this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
        this.transpiledJSContent.push(`${varName}.textContent = \`${rawContent}\`;`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
        
        // Return here to prevent further child processing
        return; 
    }

    // Existing logic for other elements
    this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
    this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

    if (Array.isArray(node.attributes)) {
        for (const attr of node.attributes) {
            const transpileFn = this.nodeToTranspilerMap[attr.type];
            if (transpileFn) transpileFn(attr, varName, context);
        }
    }

    this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: varName });
}



RawHTMLBlock(node, parentVar, context = {}) {
    const rawContent = node.content;
    const containerVar = `rawhtml_${this.getUniqueId()}`;
    
    // For <pre> and <code> tags, we'll use textContent instead of innerHTML
    // to prevent double-escaping and preserve exact formatting
    if (node.name === 'pre' || node.name === 'code') {
        this.transpiledJSContent.push(
            `const ${containerVar} = document.createElement('${node.name}');`,
            `${containerVar}.style.whiteSpace = 'pre';`,
            // Use textContent instead of innerHTML to avoid escaping
            `${containerVar}.textContent = ${JSON.stringify(rawContent)};`,
            `${parentVar}.appendChild(${containerVar});`
        );
    } 
    // For other elements, use innerHTML with proper escaping
    else {
        const escapedContent = this.escapeHtml(rawContent)
            .replace(/\\`/g, '`')
            .replace(/\\\$/g, '$');
            
        this.transpiledJSContent.push(
            `const ${containerVar} = document.createElement('${node.name || 'div'}');`,
            `${containerVar}.innerHTML = \`${escapedContent}\`;`,
            `${parentVar}.appendChild(${containerVar});`
        );
    }
}

// Simplified escapeHtml (only needed for non-pre/code elements)
escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}





// If you want to handle indentation based on AST position:
calculateIndentation(node) {
    if (!node.start || !this.customAST?.source) return '';
    
    // Get the line start position
    const source = this.customAST.source;
    let lineStart = node.start;
    while (lineStart > 0 && source[lineStart - 1] !== '\n') {
        lineStart--;
    }
    
    // Count whitespace characters
    let indent = '';
    for (let i = lineStart; i < node.start; i++) {
        if (source[i] === ' ' || source[i] === '\t') {
            indent += source[i];
        } else {
            break;
        }
    }
    
    return indent;
}

preserveRawContent(children) {
    let content = '';
    
    // Simple recursive walker to extract all text content
    function walk(nodes) {
        if (!nodes || !Array.isArray(nodes)) return;
        for (const child of nodes) {
            if (child.type === 'TextNode') {
                content += child.value;
            } else if (child.type === 'Element' || child.type === 'MustacheTag') {
                // For nested elements or mustache tags, get their original names and text
                content += `<${child.name}>`;
                walk(child.children);
                content += `</${child.name}>`;
            } else {
                // Handle any other node types gracefully
                // You might need to add more cases here depending on your AST structure
            }
        }
    }
    
    walk(children);

    // Escape special HTML characters to ensure they display as text
    return content.replace(/&/g, '&amp;')
                  .replace(/</g, '&lt;')
                  .replace(/>/g, '&gt;');
}
    Fragment(node, parentVar, context = {}) {
        ////console.log(`DEBUG: Fragment - Transpiling fragment.`);
        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if a fragment has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: parentVar });
    }

    Attribute(attr, elementVarName, context = {}) {
  // console.log(`DEBUG: ${JSON.stringify(attr)} Attribute - Processing attribute type: ${attr.type} for element ${elementVarName}`);
  switch (attr.type) {
    case "KeyValueAttribute": {
      // Check for a boolean attribute based on the AST structure.
      if (attr.value === null && attr.expression) {
        const expressionCode = escodegen.generate(attr.expression);
        this.transpiledJSContent.push(`
          // Dynamic boolean attribute: ${attr.name}
          (function() {
            if (${expressionCode}) {
              ${elementVarName}.setAttribute('${attr.name}', '');
            } else {
              ${elementVarName}.removeAttribute('${attr.name}');
            }
          })();
        `);
        return;
      }
      
      // Standard KeyValueAttribute handling (for attributes with string values).
      const attrValue = attr.value || [];
      const values = attrValue.map(valNode => {
        if (valNode.type === "Text") {
          return `\`${valNode.raw}\``;
        }
        if (valNode.type === "MustacheTag") {
          const expressionCode = escodegen.generate(valNode.expression);
          return `(${expressionCode})`;
        }
        return '';
      });

      const valueCode = values.join(' + ');
      this.transpiledJSContent.push(`${elementVarName}.setAttribute('${attr.name}', ${valueCode});`);
      break;
    }

    case "TwoWayBindingAttribute": {
 const bindVarName = attr.expression?.name;
 if (!bindVarName) {
  console.error(`ERROR: Two-way binding: Missing variable name for ${attr.name} on element ${elementVarName}.`);
  return;
 }
 if (!this.isReactiveVariable(bindVarName)) {
  console.error(
   `ERROR: Two-way binding (bind:${attr.name}) can only be used with reactive variables ` +
   `(declared with $state()). '${bindVarName}' is not a reactive variable.`
  );
  return;
 }
 this.transpiledJSContent.push(`bind(${elementVarName}, ${bindVarName});`);
 break;
}

/*
case "MustacheAttribute": {
const expression = attr.expression;
if (!expression) {
 console.error("MustacheAttribute: Missing expression");
 return;
}

let expressionCode;

// 1. Check for simple identifiers that might be a function call
if (expression.type === 'Identifier') {
 const varName = expression.name;
 const varDecl = this.findVariableDeclaration(varName);

 // Corrected logic: Set the attribute name as 'src' and the value as the variable's value
 if (varDecl && varDecl.kind === 'const' && varDecl.init && varDecl.init.type === 'Literal' && typeof varDecl.init.value === 'string') {
  this.transpiledJSContent.push(
   `${elementVarName}.setAttribute('${attr.name}', '${varDecl.init.value}');`
  );
  break;
 }
 // If it's a function, generate a function call
 if (this.isFunction(varName)) {
 expressionCode = `${varName}()`;
 } else {
 // Otherwise, it's a regular identifier
 expressionCode = escodegen.generate(expression);
 }
} else {
 // 2. Handle all other complex expressions (e.g., CallExpression, BinaryExpression)
 expressionCode = escodegen.generate(expression);
}

// Get or create a reactive derived variable for the expression
const derivedAttrValueVar = this.getOrCreateDerived(expressionCode, context);

// 3. Handle boolean-type attributes
if (attr.name && (attr.name === 'disabled' || attr.name === 'required' || attr.name === 'readonly')) {
 this.transpiledJSContent.push(
 `$effect(() => {`,
 ` ${elementVarName}.toggleAttribute("${attr.name}", !!${derivedAttrValueVar}.value);`,
 `});`
 );
}
// 4. Handle attribute spread (no name)
else if (!attr.name) {
 this.transpiledJSContent.push(
 `$effect(() => {`,
 ` if (${derivedAttrValueVar}.value) {`,
 ` ${elementVarName}.setAttribute(${derivedAttrValueVar}.value, '');`,
 ` } else {`,
 ` ${elementVarName}.removeAttribute(${derivedAttrValueVar}.value);`,
 ` }`,
 `});`
 );
}
// 5. Handle special attributes that need direct `$effect` for reactivity (e.g., 'min')
else if (attr.name === 'min') {
 this.transpiledJSContent.push(
 `$effect(() => {`,
 ` ${elementVarName}.setAttribute("${attr.name}", ${derivedAttrValueVar}.value);`,
 `});`
 );
}
// 6. Handle all other regular mustache attributes
else {
 this.transpiledJSContent.push(
 `bindAttr(${elementVarName}, "${attr.name}", () => ${derivedAttrValueVar}.value);`
 );
}
break;
}


*/

case "MustacheAttribute": {
  const expression = attr.expression;
  if (!expression) {
    console.error("MustacheAttribute: Missing expression");
    return;
  }

  let expressionCode;

  // 1. Check for simple identifiers that might be a function call
  if (expression.type === 'Identifier') {
    const varName = expression.name;
    const varDecl = this.findVariableDeclaration(varName);

    // Corrected logic: Set the attribute name as 'src' and the value as the variable's value
    if (varDecl && varDecl.kind === 'const' && varDecl.init && varDecl.init.type === 'Literal' && typeof varDecl.init.value === 'string') {
      this.transpiledJSContent.push(
        `${elementVarName}.setAttribute('${attr.name}', '${varDecl.init.value}');`
      );
      break;
    }
    // If it's a function, generate a function call
    if (this.isFunction(varName)) {
      expressionCode = `${varName}()`;
    } else {
      // Otherwise, it's a regular identifier
      expressionCode = escodegen.generate(expression);
    }
  } else {
    // 2. Handle all other complex expressions (e.g., CallExpression, BinaryExpression)
    expressionCode = escodegen.generate(expression);
  }

  // Get or create a reactive derived variable for the expression
  const derivedAttrValueVar = this.getOrCreateDerived(expressionCode, context);

  // 3. Handle boolean-type attributes
  if (attr.name && (attr.name === 'disabled' || attr.name === 'required' || attr.name === 'readonly')) {
    this.transpiledJSContent.push(
      `$effect(() => {`,
      ` ${elementVarName}.toggleAttribute("${attr.name}", !!${derivedAttrValueVar}.value);`,
      `});`
    );
  }
  // 4. Handle attribute spread (no name)
  else if (!attr.name) {
    this.transpiledJSContent.push(
      `$effect(() => {`,
      ` if (${derivedAttrValueVar}.value) {`,
      ` ${elementVarName}.setAttribute(${derivedAttrValueVar}.value, '');`,
      ` } else {`,
      ` ${elementVarName}.removeAttribute(${derivedAttrValueVar}.value);`,
      ` }`,
      `});`
    );
  }
  // 5. Handle special attributes that need direct `$effect` for reactivity (e.g., 'min')
  else if (attr.name === 'min') {
    this.transpiledJSContent.push(
      `$effect(() => {`,
      ` ${elementVarName}.setAttribute("${attr.name}", ${derivedAttrValueVar}.value);`,
      `});`
    );
  }
  // 6. Handle all other regular mustache attributes - FIXED: Remove the function wrapper
  else {
    this.transpiledJSContent.push(
      `bindAttr(${elementVarName}, "${attr.name}", ${derivedAttrValueVar});`
    );
  }
  break;
}


            case "EventHandler": {
                const eventName = attr.name;
                const eventHandlerExpression = attr.expression; // This is the AST node for the expression

                if (!eventHandlerExpression) {
                    console.error("EventHandler: Missing expression for", eventName);
                    return;
                }

                // --- Start of FIX for FunctionExpression params ---
                // Deep clone the expression to avoid modifying the original AST unnecessarily
                const clonedExpression = deepCloneAstNode(eventHandlerExpression);

                // If it's an ArrowFunctionExpression or FunctionExpression and params is null/undefined, set it to an empty array
                if ((clonedExpression.type === 'ArrowFunctionExpression' || clonedExpression.type === 'FunctionExpression') && !clonedExpression.params) {
                    clonedExpression.params = [];
                }
                // --- End of FIX ---

                // Now, transform reactive variables within the (potentially fixed) expression
                const transformedInternalExpression = transformReactiveIdentifiersInExpression(
                    clonedExpression, // Use the cloned and potentially fixed expression
                    (name) => this.isReactiveVariable(name)
                );

                // Generate the code for the (potentially transformed) expression
                const internalHandlerCode = escodegen.generate(transformedInternalExpression);

                let finalHandlerCode;

                if (eventHandlerExpression.type === 'ArrowFunctionExpression' ||
                    eventHandlerExpression.type === 'FunctionExpression') {
                    finalHandlerCode = internalHandlerCode;
                } else if (eventHandlerExpression.type === 'Identifier') {
                    finalHandlerCode = internalHandlerCode;
                } else {
                    finalHandlerCode = `() => { ${internalHandlerCode}; }`;
                }

                this.transpiledJSContent.push(`${elementVarName}.addEventListener("${eventName}", ${finalHandlerCode});`);
                break;
            }



            case "BooleanAttribute": {
  const attrName = attr.name;
  const attrValue = attr.value; // This will be true or false
  this.transpiledJSContent.push(
    `${elementVarName}.toggleAttribute("${attrName}", ${attrValue});`
  );
  break;
}
            case "BooleanIdentifierAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value; // This could be a string (e.g., "true", "false", or var name) or AST node

                // If it's a static boolean like `disabled="true"` or `disabled`
                if (typeof attrValue === 'string' && (attrValue === 'true' || attrValue === 'false' || attrValue === '')) {
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${attrValue === '' ? 'true' : attrValue});`);
                }
                // If it's an expression like `disabled={isAdmin}` or `disabled={someBooleanVar}`
                else if (attr.expression) { // This handles cases like `disabled={expression}`
                    const conditionCode = escodegen.generate(attr.expression);
                    const derivedCondition = this.getOrCreateDerived(conditionCode, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                // Fallback for simple identifier attributes like `disabled={myReactiveVar}` directly on attr.value
                else if (typeof attrValue === 'string' && this.isReactiveVariable(attrValue)) {
                    const derivedCondition = this.getOrCreateDerived(attrValue, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                else {
                    // Fallback for any other type (e.g., if it was a plain non-reactive `let myBool = true;`)
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${!!attrValue});`);
                }
                break;
            }

            default:
                this.transpiledJSContent.push(`// Unknown attribute type: ${attr.type}`);
        }
    }

    TextNode(node, parentVar) {
        const varName = `text_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: TextNode - Creating text node with var ${varName} and value "${node.value}"`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode(${JSON.stringify(node.value)});`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
    }

    MustacheTag(node, parentVar, context = {}) {
        const varName = `mustache_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: MustacheTag - Creating mustache node with var ${varName}`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode('');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (!node.expression) {
            console.error("MustacheTag: Missing expression");
            return;
        }

        let expressionCode = escodegen.generate(node.expression);

        // Check if the expression is the loop item variable itself
        // This is a specific edge case / helper, might need adjustment based on desired behavior
        if (context.itemVar && expressionCode === context.itemVar) {
            console.warn(`Implicitly accessing "${context.itemVar}.name" in an #each block. It's better to be explicit: {${context.itemVar}.name}`);
            expressionCode = `${context.itemVar}.name`; // Or handle as an error if explicit is mandatory
        }

        const derivedVar = this.getOrCreateDerived(expressionCode, context);
        this.transpiledJSContent.push(`bindText(${varName}, ${derivedVar});`);
    }


    findVariableDeclaration(varName) {
        let declaration = null;
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                if (node.type === 'VariableDeclarator' &&
                    node.id.type === 'Identifier' &&
                    node.id.name === varName) {
                    declaration = {
                        kind: parent?.kind, // Using optional chaining
                        init: node.init
                    };
                    return estraverse.VisitorOption.Break; // Correct way to stop traversal
                }
            }
        });
        return declaration;
    }




    EachStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const sourceCode = escodegen.generate(node.source);
        const itemVar = node.item.name;
        const keyVar = node.key ? node.key.name : null;

        //console.log(`DEBUG: EachStatement - Processing #each block for source: ${sourceCode}, item: ${itemVar}`);

        // 1. Create DOM structure
        const fragmentPlaceholder = `each_placeholder_${id}`;
        const eachItemsVar = `each_items_${id}`;
        const cleanupsVar = `each_cleanups_${id}`;

        this.transpiledJSContent.push(
            `const ${fragmentPlaceholder} = document.createComment('each block');`,
            `${parentVar}.appendChild(${fragmentPlaceholder});`,
            `let ${eachItemsVar} = [];`,
            `let ${cleanupsVar} = [];`
        );

        // 2. Temporarily store and transpile the block body
        // Ensure node.body.body is an array, as `transpileBlockContent` expects it.
        const bodyNodes = Array.isArray(node.body?.body) ? node.body.body : [];
        const itemBlockData = this.transpileBlockContent(bodyNodes, { ...context, itemVar: itemVar, keyVar: keyVar });

        // 3. Generate the render function for a single item, including its local deriveds
        this.transpiledJSContent.push(
            `const render_each_item_${id} = (${itemVar}) => {`,
            ` const ${itemBlockData.fragmentVar} = document.createDocumentFragment();`,
            ` ${itemBlockData.blockDeriveds}`,
            ` ${itemBlockData.blockJS}`,
            ` return { nodes: Array.from(${itemBlockData.fragmentVar}.childNodes), cleanups: [${itemBlockData.blockCleanups}] };`,
            `};`
        );

        // 4. Create the reactive effect that re-renders the list
        this.transpiledJSContent.push(
            `$effect(() => {`,
            ` ${cleanupsVar}.forEach(fn => fn());`,
            ` ${cleanupsVar}.length = 0;`,
            ` ${eachItemsVar}.forEach(el => el.remove());`,
            ` ${eachItemsVar}.length = 0;`,
            ` const sourceArray = ${this.getOrCreateDerived(sourceCode, context)}.value ?? [];`, // <-- MODIFIED: Access .value of derived source array
            ` sourceArray.forEach((${itemVar}, index) => {`,
            `  const itemData = render_each_item_${id}(${itemVar});`,
            `  ${fragmentPlaceholder}.after(...itemData.nodes);`,
            `  ${eachItemsVar}.push(...itemData.nodes);`,
            `  ${cleanupsVar}.push(...itemData.cleanups);`,
            ` });`,
            `});`
        );
    }


    IfStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const placeholderCommentVar = `if_placeholder_${id}`;

        //console.log(`DEBUG: IfStatement - Processing #if block.`);

        // The condition for the if statement. Use getOrCreateDerived for the condition itself.
        const conditionCode = escodegen.generate(node.test);
        const derivedConditionVar = this.getOrCreateDerived(conditionCode, context);

        this.transpiledJSContent.push(`const ${placeholderCommentVar} = document.createComment('if block');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${placeholderCommentVar});`);

        // --- FIX: Ensure node.consequent.body is an array ---
        const consequentNodes = Array.isArray(node.consequent?.body) ? node.consequent.body : [];
        const ifBranchData = this.transpileBlockContent(consequentNodes, context);
        const createIfFragmentFunction = `create_if_fragment_${id}`;

        this.transpiledJSContent.push(`const ${createIfFragmentFunction} = () => {`);
        this.transpiledJSContent.push(` const ${ifBranchData.fragmentVar} = document.createDocumentFragment();`);
        this.transpiledJSContent.push(ifBranchData.blockDeriveds);
        this.transpiledJSContent.push(ifBranchData.blockJS);
        this.transpiledJSContent.push(` return {`);
        this.transpiledJSContent.push(`  nodes: Array.from(${ifBranchData.fragmentVar}.childNodes),`);
        this.transpiledJSContent.push(`  cleanups: () => { ${ifBranchData.blockCleanups} }`);
        this.transpiledJSContent.push(` };`);
        this.transpiledJSContent.push(`};`);

        let createElseFragmentFunction = null;
        if (node.alternate) {
            // --- FIX: Ensure node.alternate.body is an array ---
            const alternateNodes = Array.isArray(node.alternate?.body) ? node.alternate.body : [];
            const elseBranchData = this.transpileBlockContent(alternateNodes, context);
            createElseFragmentFunction = `create_else_fragment_${id}`;

            this.transpiledJSContent.push(`const ${createElseFragmentFunction} = () => {`);
            this.transpiledJSContent.push(` const ${elseBranchData.fragmentVar} = document.createDocumentFragment();`);
            this.transpiledJSContent.push(elseBranchData.blockDeriveds);
            this.transpiledJSContent.push(elseBranchData.blockJS);
            this.transpiledJSContent.push(` return {`);
            this.transpiledJSContent.push(`  nodes: Array.from(${elseBranchData.fragmentVar}.childNodes),`);
            this.transpiledJSContent.push(`  cleanups: () => { ${elseBranchData.blockCleanups} }`);
            this.transpiledJSContent.push(` };`);
            this.transpiledJSContent.push(`};`);
        }

        this.transpiledJSContent.push(`let if_elements_${id} = [];`);
        this.transpiledJSContent.push(`let if_element_cleanups_${id} = [];`);

        this.transpiledJSContent.push(`$effect(() => {`);
        this.transpiledJSContent.push(` // Run previous cleanups (if any)`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.forEach(fn => fn());`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.length = 0;`);

        this.transpiledJSContent.push(` // Remove previous elements from DOM`);
        this.transpiledJSContent.push(` if_elements_${id}.forEach(el => el.remove());`);
        this.transpiledJSContent.push(` if_elements_${id}.length = 0;`);

        this.transpiledJSContent.push(` let fragmentData;`);
        this.transpiledJSContent.push(` if (${derivedConditionVar}.value) {`); // Access value of derived condition
        this.transpiledJSContent.push(`  fragmentData = ${createIfFragmentFunction}();`);
        this.transpiledJSContent.push(` } `);

        if (createElseFragmentFunction) {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = ${createElseFragmentFunction}();`);
            this.transpiledJSContent.push(` }`);
        } else {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = null;`); // Explicitly set to null if no else branch
            this.transpiledJSContent.push(` }`);
        }

        this.transpiledJSContent.push(` if (fragmentData) {`);
        this.transpiledJSContent.push(`  ${placeholderCommentVar}.after(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_elements_${id}.push(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_element_cleanups_${id}.push(fragmentData.cleanups);`);
        // --- FIX: Corrected typo `this.transpiledJSContent.transpiledJSContent.push` to `this.transpiledJSContent.push` ---
        this.transpiledJSContent.push(` }`);
        this.transpiledJSContent.push(`});`);
    }


    // This helper function is used by IfStatement and EachStatement to create a self-contained block
    transpileBlockContent(blockNodes, context = {}) {
        const originalTranspiledContent = this.transpiledJSContent;
        const originalComponentCleanups = this.componentCleanups;
        const originalLocalDeriveds = this.localDerivedDeclarations;

        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.localDerivedDeclarations = [];

        const fragmentVar = `fragmentRoot_${this.getUniqueId()}`;
        ////console.log(`DEBUG: transpileBlockContent - Starting new block context for fragment ${fragmentVar}`);

        // --- FIX: Ensure blockNodes is an array before passing to transpileBlock ---
        // This makes `transpileBlockContent` robust to cases where `blockNodes` might not be an array.
        this.transpileBlock(Array.isArray(blockNodes) ? blockNodes : [], { ...context, parentVar: fragmentVar });

        const blockJS = this.transpiledJSContent.join('\n');
        const blockCleanups = this.componentCleanups.join('\n');
        const blockDeriveds = this.localDerivedDeclarations.join('\n');

        this.transpiledJSContent = originalTranspiledContent;
        this.componentCleanups = originalComponentCleanups;
        this.localDerivedDeclarations = originalLocalDeriveds;

        ////console.log(`DEBUG: transpileBlockContent - Finishing block context for fragment ${fragmentVar}`);

        return {
            blockJS,
            blockCleanups,
            blockDeriveds,
            fragmentVar
        };
    }

    

    // --- Output Generation ---

async output() {
    try {
        const mainComponentJS = this.transpiledJSContent.join('\n');
        const mainComponentCleanups = this.componentCleanups.join('\n');
        const generatedDerivedDeclarations = this.globalDerivedDeclarations.join('\n');

        // Process $onMount blocks with proper async handling (The $effect/RAF logic)
        const onMountEffects = this.onMountCallbacks.map((onMountNode) => {
            const callback = onMountNode.expression.arguments[0];
            const isAsync = callback.async;
            const body = escodegen.generate(callback.body);
            
            return `
        // $onMount effect
        $effect(() => {
            let cleanupFn;
            const mount = ${isAsync ? 'async ' : ''}function() {
                try {
                    ${body}
                } catch (e) {
                    console.error('Mount error:', e);
                    throw e;
                }
            };

            // Double RAF for reliable DOM mounting
            let rafId;
            const scheduleMount = () => {
                cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(() => {
                    requestAnimationFrame(${isAsync ? 'async ' : ''}() => {
                        const result = mount();
                        if (result && typeof result.then === 'function') {
                            result.then(cleanup => {
                                if (typeof cleanup === 'function') {
                                    cleanupFn = cleanup;
                                }
                            });
                        } else if (typeof result === 'function') {
                            cleanupFn = result;
                        }
                    });
                });
            };
            
            scheduleMount();
            
            return () => {
                cancelAnimationFrame(rafId);
                if (cleanupFn) cleanupFn();
            };
        });
        `;
        }).join('\n');


        const finalJsCode = `

${generatedDerivedDeclarations}

export function renderComponent(targetElement) {
    const appRoot = targetElement || document.getElementById("app");
    
    if (!appRoot) {
        console.log("App root element not found");
        return () => {};
    }

    while (appRoot.firstChild) {
        appRoot.removeChild(appRoot.firstChild);
    }

    // 1. User's State and Functions (original script content)
    ${this.mainPageOriginalJS}    
    
    // 2. Transpiled DOM Creation and Reactive Bindings
    ${mainComponentJS}    
    
    // 3. Mount Effects (triggers $effect/RAF cycle)
    ${onMountEffects}

    // 4. Return Cleanup Function
    return () => {
        ${mainComponentCleanups}
        while (appRoot.firstChild) {
            appRoot.removeChild(appRoot.firstChild);
        }
    };
}
`.trim();

        // Return only the component definition code
        return { transpiledJSCode: finalJsCode };    
    } catch (err) {
        console.error('Failed to generate output:', err);
        return {};
    }
}


}