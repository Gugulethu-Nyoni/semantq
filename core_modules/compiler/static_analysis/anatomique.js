import { writeFile, mkdir } from 'node:fs/promises';
import { join, basename } from 'node:path';
import escodegen from 'escodegen';
import { parse } from 'acorn';
import * as estraverse from 'estraverse'; // Import estraverse

// Helper for deep cloning an AST node (needed because we'll modify it)
function deepCloneAstNode(node) {
    // A simple JSON parse/stringify is usually sufficient for most ASTs
    // generated by Acorn, as long as they don't contain circular references
    // or non-JSON-serializable properties (like functions).
    return JSON.parse(JSON.stringify(node));
}

// Recursive AST transformation function
// This function will walk the AST and replace any reactive variable identifier
// with a MemberExpression that accesses its `.value` property.
function transformReactiveIdentifiersInExpression(node, isReactiveVariableFn) {
    if (!node || typeof node !== 'object' || !node.type) {
        return node;
    }

    // Process the current node
    if (node.type === 'Identifier' && isReactiveVariableFn(node.name)) {
        // If this identifier is a reactive variable, transform it to `identifier.value`
        // Ensure it's not already part of a '.value' access (though unlikely if it's a bare Identifier)
        return {
            type: 'MemberExpression',
            object: deepCloneAstNode(node), // The original identifier becomes the object
            property: { type: 'Identifier', name: 'value' },
            computed: false,
            optional: false
        };
    }

    // Recursively process children of the current node
    for (const key in node) {
        if (node.hasOwnProperty(key) && key !== 'loc' && key !== 'range' && key !== 'comments' && key !== 'tokens') {
            const value = node[key];
            if (Array.isArray(value)) {
                node[key] = value.map(item => transformReactiveIdentifiersInExpression(item, isReactiveVariableFn));
            } else if (typeof value === 'object' && value !== null) {
                node[key] = transformReactiveIdentifiersInExpression(value, isReactiveVariableFn);
            }
        }
    }
    return node;
}


export default class Anatomique {
    constructor(jsAST, cssAST, customAST, filePath) {
        this.filePath = filePath;
        this.fileName = basename(filePath, '.ast');
        this.appRootId = 'app';
        this.jsAST = jsAST;
        this.cssAST = cssAST;
        this.customAST = customAST;
        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.transpiledHTML = '';
        this.distDir = './dist';
        this.addState = true;


        this.reactiveVariables = new Set();
        this.staticVariables = new Set();

        this.globalDerivedCache = new Map(); // Map: expressionString -> varName
        this.globalDerivedDeclarations = []; // Array of actual 'const varName = $derived(...);' strings

        this.localDerivedDeclarations = null; // A temporary array for block-local deriveds

        this.analyzeJsAST(); // Populate `this.reactiveVariables` and `this.staticVariables`

        this.nodeToTranspilerMap = {
            Element: this.Element.bind(this),
            KeyValueAttribute: this.Attribute.bind(this),
            BooleanAttribute: this.Attribute.bind(this),
            EventHandler: this.Attribute.bind(this),
            TwoWayBindingAttribute: this.Attribute.bind(this),
            MustacheAttribute: this.Attribute.bind(this),
            BooleanIdentifierAttribute: this.Attribute.bind(this),
            Fragment: this.Fragment.bind(this),
            TextNode: this.TextNode.bind(this),
            MustacheTag: this.MustacheTag.bind(this),
            IfStatement: this.IfStatement.bind(this),
            EachStatement: this.EachStatement.bind(this),

        };

        this.transpiledJSContent.push(`const appRoot = document.getElementById('${this.appRootId}');\n`);

        this.traverse();

        //this.output();
    }

    // --- Utility Methods ---

    analyzeJsAST() {
        // Add a debug log here
        //console.log("DEBUG: analyzeJsAST - jsAST content received:", this.jsAST?.content ? 'Exists' : 'Undefined/Null');
        if (!this.jsAST || !this.jsAST.content) {
           // console.warn("DEBUG: analyzeJsAST - jsAST or its content is undefined/null. Skipping analysis.");
            return;
        }

        // Use estraverse to walk the AST more thoroughly
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                if (node.type === 'VariableDeclarator') {
                    const varName = node.id.name; // Assuming simple identifiers for now

                    if (node.init && node.init.type === 'CallExpression') {
                        const callee = node.init.callee;
                        // Check if it's a call to a reactivity primitive ($state, $derived, or $props)
                        if (callee.type === 'Identifier' &&
                            (callee.name === '$state' || callee.name === '$derived' || callee.name === '$props')) {
                            this.reactiveVariables.add(varName);
                            this.staticVariables.delete(varName); // Ensure it's not also marked static
                        } else {
                            // It's a function call, but not a reactivity primitive (e.g., `let x = someFunc();`)
                            if (!this.reactiveVariables.has(varName)) { // Only add if not already marked reactive
                                this.staticVariables.add(varName);
                            }
                        }
                    } else if (node.id.type === 'Identifier') {
                        // Plain variable declaration (e.g., `let x = 10;`, `const y = 'hello';`, `let z;`)
                        // Add to static variables if not already identified as reactive
                        if (!this.reactiveVariables.has(varName)) {
                            this.staticVariables.add(varName);
                        }
                    }
                }
                // Future consideration: Handle function parameters, loop variables, etc., if they could affect reactivity.
                // For now, this covers top-level `let` and `const`.
            },
        });

        // Optional: Log for debugging
        //console.log("Reactive variables detected:", Array.from(this.reactiveVariables));
        //console.log("Static variables detected:", Array.from(this.staticVariables));
    }

    isReactiveVariable(varName) {
        return this.reactiveVariables.has(varName);
    }

    getUniqueId(prefix = '') {
        return `${prefix}${Math.random().toString(36).slice(2, 8)}`;
    }

    // --- Helper to get/create a derived variable ---
    getOrCreateDerived(expressionCode, context = {}) {
        // If the expression contains a loop variable, we must generate a new derived
        // every time and cannot use the global cache.
        const isLoopItemInExpression = context.itemVar && expressionCode.includes(context.itemVar);
        const isGlobalScope = !this.localDerivedDeclarations;

        if (isGlobalScope && !isLoopItemInExpression && this.globalDerivedCache.has(expressionCode)) {
            return this.globalDerivedCache.get(expressionCode);
        }

        let transformedExpressionCode;
        try {
            // Parse the expression into its own mini-AST
            // Add debug log for parsing derived expressions
            //console.log(`DEBUG: getOrCreateDerived - Parsing expression: (${expressionCode})`);
            const parsedProgram = parse(`(${expressionCode})`, { ecmaVersion: 2020 });
            const expressionAst = parsedProgram.body[0].expression;
            // Apply the transformation using our `isReactiveVariable` checker
            const transformedAst = transformReactiveIdentifiersInExpression(expressionAst, (name) => this.isReactiveVariable(name));
            transformedExpressionCode = escodegen.generate(transformedAst);
        } catch (e) {
            console.error(`Error parsing or transforming derived expression "${expressionCode}":`, e);
            transformedExpressionCode = expressionCode; // Fallback to original code
        }

        const derivedVarName = this.getUniqueId('derived_');
        const derivedDeclaration = `const ${derivedVarName} = $derived(() => ${transformedExpressionCode});`;

        if (isGlobalScope) {
            this.globalDerivedCache.set(expressionCode, derivedVarName);
            this.globalDerivedDeclarations.push(derivedDeclaration);
        } else {
            // Store in the local block's declarations
            this.localDerivedDeclarations.push(derivedDeclaration);
        }

        return derivedVarName;
    }


    // --- Traversal Method ---
            traverse() {
            // The AST is now just the Fragment node.
            // Assign the AST directly to the variable.
            const htmlFragment = this.customAST;

            // We can now access the children directly from the htmlFragment.
            if (!htmlFragment || !Array.isArray(htmlFragment.children)) {
                console.warn("AST fragment or its children not found or not an array. No HTML to transpile.");
                return;
            }

            // Now, find the 'customSyntax' node within the fragment's children.
            const customSyntaxNode = htmlFragment.children.find(
                child => child.type === 'Element' && child.name === 'customSyntax'
            );

            if (!customSyntaxNode) {
                console.error("Custom syntax wrapper element 'customSyntax' not found. Cannot transpile HTML.");
                return;
            }

            if (!Array.isArray(customSyntaxNode.children)) {
                console.error("Custom syntax wrapper element 'customSyntax' has no children or children is not an array. Cannot transpile.");
                return;
            }

           // console.log("DEBUG: traverse - Found 'customSyntax' element with children. Starting transpilation block.");
            
            // Now you can traverse the children of the customSyntax node.
            this.transpileBlock(customSyntaxNode.children, { parentVar: 'appRoot' });
        }



    transpileBlock(blockNodes, context) {
        // --- FIX: Ensure blockNodes is iterable ---
        // This is the primary fix for `TypeError: blockNodes is not iterable`.
        // If blockNodes is null/undefined/not an array, it defaults to an empty array.
        const nodesToTranspile = Array.isArray(blockNodes) ? blockNodes : [];

        // Add debug log for transpileBlock
        ////console.log(`DEBUG: transpileBlock - Processing ${nodesToTranspile.length} nodes for parent: ${context.parentVar}`);

        for (const child of nodesToTranspile) {
            // Skip comments
            if (child.type === 'CommentBlock') {
                ////console.log(`DEBUG: transpileBlock - Skipping CommentBlock.`);
                continue;
            }

            const transpileFn = this.nodeToTranspilerMap[child.type];
            if (transpileFn) {
                ////console.log(`DEBUG: transpileBlock - Transpiling node type: ${child.type}`);
                transpileFn(child, context.parentVar, context);
            } else {
                console.warn(`No transpiler function found for node type: ${child.type} within a block. Node:`, child);
            }
        }
    }


    // --- Node Transpilation Methods ---

    Element(node, parentVar, context = {}) {
        const varName = `${node.name}_elem_${this.getUniqueId()}`;
        //console.log(`DEBUG: Element - Creating element ${node.name} with var ${varName}`);

        this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (Array.isArray(node.attributes)) {
            //console.log(`DEBUG: Element - Processing ${node.attributes.length} attributes for ${varName}.`);
            for (const attr of node.attributes) {
                const transpileFn = this.nodeToTranspilerMap[attr.type];
                if (transpileFn) transpileFn(attr, varName, context);
            }
        }

        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if an element has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: varName });
    }

    Fragment(node, parentVar, context = {}) {
        ////console.log(`DEBUG: Fragment - Transpiling fragment.`);
        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if a fragment has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: parentVar });
    }

    Attribute(attr, elementVarName, context = {}) {
        ////console.log(`DEBUG: Attribute - Processing attribute type: ${attr.type} for element ${elementVarName}`);
        switch (attr.type) {
            case "KeyValueAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value?.[0]?.data || "";
                this.transpiledJSContent.push(`${elementVarName}.setAttribute("${attrName}", ${JSON.stringify(attrValue)});`);
                break;
            }

            case "TwoWayBindingAttribute": {
                const bindVarName = attr.expression?.name; // Assumes simple Identifier for binding

                if (!bindVarName) {
                    console.error(`ERROR: Two-way binding: Missing variable name for ${attr.name} on element ${elementVarName}.`);
                    return;
                }

                if (!this.isReactiveVariable(bindVarName)) {
                    console.error(
                        `ERROR: Two-way binding (bind:${attr.name}) can only be used with reactive variables ` +
                        `(declared with $state()). '${bindVarName}' is not a reactive variable.`
                    );
                    return;
                }
                this.transpiledJSContent.push(`bind(${elementVarName}, ${bindVarName});`);
                break;
            }

            case "MustacheAttribute": {
                const expression = attr.expression;
                if (!expression) {
                    console.error("MustacheAttribute: Missing expression");
                    return;
                }

                // Check if this is a static string variable (like boolAttr = 'disabled')
                if (expression.type === 'Identifier') {
                    const varName = expression.name;
                    const varDecl = this.findVariableDeclaration(varName);

                    // If it's a const declaration with a string literal value
                    if (varDecl && varDecl.kind === 'const' &&
                        varDecl.init && varDecl.init.type === 'Literal' &&
                        typeof varDecl.init.value === 'string') {

                        // Directly use the static string value
                        this.transpiledJSContent.push(
                            `${elementVarName}.setAttribute("${varDecl.init.value}", "");`
                        );
                        break;
                    }
                }

                // Fallback to reactive handling for dynamic values
                const dynValueCode = escodegen.generate(expression);
                const derivedAttrValueVar = this.getOrCreateDerived(dynValueCode, context);

                if (!attr.name) {
                    // Boolean attribute spread
                    this.transpiledJSContent.push(
                        `if (${derivedAttrValueVar}.value) {`,
                        `  ${elementVarName}.setAttribute(${derivedAttrValueVar}.value, '');`,
                        `} else {`,
                        `  ${elementVarName}.removeAttribute(${derivedAttrValueVar}.value);`,
                        `}`
                    );
                } else {
                    // Regular mustache attribute
                    this.transpiledJSContent.push(
                        `bindAttr(${elementVarName}, "${attr.name}", () => ${derivedAttrValueVar}.value);`
                    );
                }
                break;
            }


            case "EventHandler": {
                const eventName = attr.name;
                const eventHandlerExpression = attr.expression; // This is the AST node for the expression

                if (!eventHandlerExpression) {
                    console.error("EventHandler: Missing expression for", eventName);
                    return;
                }

                // --- Start of FIX for FunctionExpression params ---
                // Deep clone the expression to avoid modifying the original AST unnecessarily
                const clonedExpression = deepCloneAstNode(eventHandlerExpression);

                // If it's an ArrowFunctionExpression or FunctionExpression and params is null/undefined, set it to an empty array
                if ((clonedExpression.type === 'ArrowFunctionExpression' || clonedExpression.type === 'FunctionExpression') && !clonedExpression.params) {
                    clonedExpression.params = [];
                }
                // --- End of FIX ---

                // Now, transform reactive variables within the (potentially fixed) expression
                const transformedInternalExpression = transformReactiveIdentifiersInExpression(
                    clonedExpression, // Use the cloned and potentially fixed expression
                    (name) => this.isReactiveVariable(name)
                );

                // Generate the code for the (potentially transformed) expression
                const internalHandlerCode = escodegen.generate(transformedInternalExpression);

                let finalHandlerCode;

                if (eventHandlerExpression.type === 'ArrowFunctionExpression' ||
                    eventHandlerExpression.type === 'FunctionExpression') {
                    finalHandlerCode = internalHandlerCode;
                } else if (eventHandlerExpression.type === 'Identifier') {
                    finalHandlerCode = internalHandlerCode;
                } else {
                    finalHandlerCode = `() => { ${internalHandlerCode}; }`;
                }

                this.transpiledJSContent.push(`${elementVarName}.addEventListener("${eventName}", ${finalHandlerCode});`);
                break;
            }



            case "BooleanAttribute":
            case "BooleanIdentifierAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value; // This could be a string (e.g., "true", "false", or var name) or AST node

                // If it's a static boolean like `disabled="true"` or `disabled`
                if (typeof attrValue === 'string' && (attrValue === 'true' || attrValue === 'false' || attrValue === '')) {
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${attrValue === '' ? 'true' : attrValue});`);
                }
                // If it's an expression like `disabled={isAdmin}` or `disabled={someBooleanVar}`
                else if (attr.expression) { // This handles cases like `disabled={expression}`
                    const conditionCode = escodegen.generate(attr.expression);
                    const derivedCondition = this.getOrCreateDerived(conditionCode, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                // Fallback for simple identifier attributes like `disabled={myReactiveVar}` directly on attr.value
                else if (typeof attrValue === 'string' && this.isReactiveVariable(attrValue)) {
                    const derivedCondition = this.getOrCreateDerived(attrValue, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                else {
                    // Fallback for any other type (e.g., if it was a plain non-reactive `let myBool = true;`)
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${!!attrValue});`);
                }
                break;
            }

            default:
                this.transpiledJSContent.push(`// Unknown attribute type: ${attr.type}`);
        }
    }

    TextNode(node, parentVar) {
        const varName = `text_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: TextNode - Creating text node with var ${varName} and value "${node.value}"`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode(${JSON.stringify(node.value)});`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
    }

    MustacheTag(node, parentVar, context = {}) {
        const varName = `mustache_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: MustacheTag - Creating mustache node with var ${varName}`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode('');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (!node.expression) {
            console.error("MustacheTag: Missing expression");
            return;
        }

        let expressionCode = escodegen.generate(node.expression);

        // Check if the expression is the loop item variable itself
        // This is a specific edge case / helper, might need adjustment based on desired behavior
        if (context.itemVar && expressionCode === context.itemVar) {
            console.warn(`Implicitly accessing "${context.itemVar}.name" in an #each block. It's better to be explicit: {${context.itemVar}.name}`);
            expressionCode = `${context.itemVar}.name`; // Or handle as an error if explicit is mandatory
        }

        const derivedVar = this.getOrCreateDerived(expressionCode, context);
        this.transpiledJSContent.push(`bindText(${varName}, ${derivedVar});`);
    }


    findVariableDeclaration(varName) {
        let declaration = null;
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                if (node.type === 'VariableDeclarator' &&
                    node.id.type === 'Identifier' &&
                    node.id.name === varName) {
                    declaration = {
                        kind: parent?.kind, // Using optional chaining
                        init: node.init
                    };
                    return estraverse.VisitorOption.Break; // Correct way to stop traversal
                }
            }
        });
        return declaration;
    }




    EachStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const sourceCode = escodegen.generate(node.source);
        const itemVar = node.item.name;
        const keyVar = node.key ? node.key.name : null;

        //console.log(`DEBUG: EachStatement - Processing #each block for source: ${sourceCode}, item: ${itemVar}`);

        // 1. Create DOM structure
        const fragmentPlaceholder = `each_placeholder_${id}`;
        const eachItemsVar = `each_items_${id}`;
        const cleanupsVar = `each_cleanups_${id}`;

        this.transpiledJSContent.push(
            `const ${fragmentPlaceholder} = document.createComment('each block');`,
            `${parentVar}.appendChild(${fragmentPlaceholder});`,
            `let ${eachItemsVar} = [];`,
            `let ${cleanupsVar} = [];`
        );

        // 2. Temporarily store and transpile the block body
        // Ensure node.body.body is an array, as `transpileBlockContent` expects it.
        const bodyNodes = Array.isArray(node.body?.body) ? node.body.body : [];
        const itemBlockData = this.transpileBlockContent(bodyNodes, { ...context, itemVar: itemVar, keyVar: keyVar });

        // 3. Generate the render function for a single item, including its local deriveds
        this.transpiledJSContent.push(
            `const render_each_item_${id} = (${itemVar}) => {`,
            ` const ${itemBlockData.fragmentVar} = document.createDocumentFragment();`,
            ` ${itemBlockData.blockDeriveds}`,
            ` ${itemBlockData.blockJS}`,
            ` return { nodes: Array.from(${itemBlockData.fragmentVar}.childNodes), cleanups: [${itemBlockData.blockCleanups}] };`,
            `};`
        );

        // 4. Create the reactive effect that re-renders the list
        this.transpiledJSContent.push(
            `$effect(() => {`,
            ` ${cleanupsVar}.forEach(fn => fn());`,
            ` ${cleanupsVar}.length = 0;`,
            ` ${eachItemsVar}.forEach(el => el.remove());`,
            ` ${eachItemsVar}.length = 0;`,
            ` const sourceArray = ${this.getOrCreateDerived(sourceCode, context)}.value ?? [];`, // <-- MODIFIED: Access .value of derived source array
            ` sourceArray.forEach((${itemVar}, index) => {`,
            `  const itemData = render_each_item_${id}(${itemVar});`,
            `  ${fragmentPlaceholder}.after(...itemData.nodes);`,
            `  ${eachItemsVar}.push(...itemData.nodes);`,
            `  ${cleanupsVar}.push(...itemData.cleanups);`,
            ` });`,
            `});`
        );
    }


    IfStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const placeholderCommentVar = `if_placeholder_${id}`;

        //console.log(`DEBUG: IfStatement - Processing #if block.`);

        // The condition for the if statement. Use getOrCreateDerived for the condition itself.
        const conditionCode = escodegen.generate(node.test);
        const derivedConditionVar = this.getOrCreateDerived(conditionCode, context);

        this.transpiledJSContent.push(`const ${placeholderCommentVar} = document.createComment('if block');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${placeholderCommentVar});`);

        // --- FIX: Ensure node.consequent.body is an array ---
        const consequentNodes = Array.isArray(node.consequent?.body) ? node.consequent.body : [];
        const ifBranchData = this.transpileBlockContent(consequentNodes, context);
        const createIfFragmentFunction = `create_if_fragment_${id}`;

        this.transpiledJSContent.push(`const ${createIfFragmentFunction} = () => {`);
        this.transpiledJSContent.push(` const ${ifBranchData.fragmentVar} = document.createDocumentFragment();`);
        this.transpiledJSContent.push(ifBranchData.blockDeriveds);
        this.transpiledJSContent.push(ifBranchData.blockJS);
        this.transpiledJSContent.push(` return {`);
        this.transpiledJSContent.push(`  nodes: Array.from(${ifBranchData.fragmentVar}.childNodes),`);
        this.transpiledJSContent.push(`  cleanups: () => { ${ifBranchData.blockCleanups} }`);
        this.transpiledJSContent.push(` };`);
        this.transpiledJSContent.push(`};`);

        let createElseFragmentFunction = null;
        if (node.alternate) {
            // --- FIX: Ensure node.alternate.body is an array ---
            const alternateNodes = Array.isArray(node.alternate?.body) ? node.alternate.body : [];
            const elseBranchData = this.transpileBlockContent(alternateNodes, context);
            createElseFragmentFunction = `create_else_fragment_${id}`;

            this.transpiledJSContent.push(`const ${createElseFragmentFunction} = () => {`);
            this.transpiledJSContent.push(` const ${elseBranchData.fragmentVar} = document.createDocumentFragment();`);
            this.transpiledJSContent.push(elseBranchData.blockDeriveds);
            this.transpiledJSContent.push(elseBranchData.blockJS);
            this.transpiledJSContent.push(` return {`);
            this.transpiledJSContent.push(`  nodes: Array.from(${elseBranchData.fragmentVar}.childNodes),`);
            this.transpiledJSContent.push(`  cleanups: () => { ${elseBranchData.blockCleanups} }`);
            this.transpiledJSContent.push(` };`);
            this.transpiledJSContent.push(`};`);
        }

        this.transpiledJSContent.push(`let if_elements_${id} = [];`);
        this.transpiledJSContent.push(`let if_element_cleanups_${id} = [];`);

        this.transpiledJSContent.push(`$effect(() => {`);
        this.transpiledJSContent.push(` // Run previous cleanups (if any)`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.forEach(fn => fn());`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.length = 0;`);

        this.transpiledJSContent.push(` // Remove previous elements from DOM`);
        this.transpiledJSContent.push(` if_elements_${id}.forEach(el => el.remove());`);
        this.transpiledJSContent.push(` if_elements_${id}.length = 0;`);

        this.transpiledJSContent.push(` let fragmentData;`);
        this.transpiledJSContent.push(` if (${derivedConditionVar}.value) {`); // Access value of derived condition
        this.transpiledJSContent.push(`  fragmentData = ${createIfFragmentFunction}();`);
        this.transpiledJSContent.push(` } `);

        if (createElseFragmentFunction) {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = ${createElseFragmentFunction}();`);
            this.transpiledJSContent.push(` }`);
        } else {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = null;`); // Explicitly set to null if no else branch
            this.transpiledJSContent.push(` }`);
        }

        this.transpiledJSContent.push(` if (fragmentData) {`);
        this.transpiledJSContent.push(`  ${placeholderCommentVar}.after(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_elements_${id}.push(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_element_cleanups_${id}.push(fragmentData.cleanups);`);
        // --- FIX: Corrected typo `this.transpiledJSContent.transpiledJSContent.push` to `this.transpiledJSContent.push` ---
        this.transpiledJSContent.push(` }`);
        this.transpiledJSContent.push(`});`);
    }


    // This helper function is used by IfStatement and EachStatement to create a self-contained block
    transpileBlockContent(blockNodes, context = {}) {
        const originalTranspiledContent = this.transpiledJSContent;
        const originalComponentCleanups = this.componentCleanups;
        const originalLocalDeriveds = this.localDerivedDeclarations;

        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.localDerivedDeclarations = [];

        const fragmentVar = `fragmentRoot_${this.getUniqueId()}`;
        ////console.log(`DEBUG: transpileBlockContent - Starting new block context for fragment ${fragmentVar}`);

        // --- FIX: Ensure blockNodes is an array before passing to transpileBlock ---
        // This makes `transpileBlockContent` robust to cases where `blockNodes` might not be an array.
        this.transpileBlock(Array.isArray(blockNodes) ? blockNodes : [], { ...context, parentVar: fragmentVar });

        const blockJS = this.transpiledJSContent.join('\n');
        const blockCleanups = this.componentCleanups.join('\n');
        const blockDeriveds = this.localDerivedDeclarations.join('\n');

        this.transpiledJSContent = originalTranspiledContent;
        this.componentCleanups = originalComponentCleanups;
        this.localDerivedDeclarations = originalLocalDeriveds;

        ////console.log(`DEBUG: transpileBlockContent - Finishing block context for fragment ${fragmentVar}`);

        return {
            blockJS,
            blockCleanups,
            blockDeriveds,
            fragmentVar
        };
    }


    // --- Output Generation ---
    async output() {
        try {
            await mkdir(this.distDir, { recursive: true });

            const strippedFileName = this.filePath.replace('.ast', '');
            const finalFileName = basename(strippedFileName);
            const jsFilePath = join(this.distDir, `${finalFileName}.js`);
            // FIX START
            const htmlFilePath = join(this.distDir, 'index.html'); // Moved this line up
            // FIX END

            // Add debug log for jsAST.content before escodegen.generate
            //console.log("DEBUG: output - jsAST.content type before escodegen:", this.jsAST?.content?.type);
            if (!this.jsAST || !this.jsAST.content) {
                console.error("ERROR: output - this.jsAST or this.jsAST.content is undefined or null. Cannot generate originalJsCode.");
                // Ensure output always returns an object, even on error, to prevent subsequent destructuring errors
                return { transpiledJSCode: '// Error: JS AST content missing.' };
            }

            const originalJsCode = escodegen.generate(this.jsAST.content);

            // Capture all top-level transpiled JS content and cleanups
            const mainComponentJS = this.transpiledJSContent.join('\n');
            const mainComponentCleanups = this.componentCleanups.join('\n');

            const finalJsCode = `

// Original script content (includes $state, $derived, $props declarations)
${originalJsCode}

// Global Derived Declarations created by the transpiler
${this.globalDerivedDeclarations.join('\n')}

export function renderComponent(targetElement) {
    const fragment = document.createDocumentFragment();

    // Transpiled DOM creation and reactive effects
    ${mainComponentJS}

    // Append the fragment to the target element
    targetElement.appendChild(fragment);

    // Lifecycle management: return a cleanup function
    return () => {
        // Run all component-level cleanups
        ${mainComponentCleanups}
        // Remove all direct children added by this component
        while (targetElement.firstChild) {
            targetElement.removeChild(targetElement.firstChild);
        }
    };
}
`.trim();

            //await writeFile(jsFilePath, finalJsCode, 'utf8');

            return { transpiledJSCode: finalJsCode }

            /*
                        const htmlContent = `
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Semantq Output</title>
            </head>
            <body>
                <div id="${this.appRootId}"></div>
                <script type="module">
                    import { renderComponent } from './${finalFileName}.js';

                    const appRoot = document.getElementById('${this.appRootId}');
                    const cleanup = renderComponent(appRoot);

                    // Optional: If you had a way to unmount or re-render, you'd call cleanup()
                    // For a single-page app, this might not be strictly necessary unless
                    // you're dynamically loading/unloading components.
                    // Example: setTimeout(cleanup, 5000); // Unmount after 5 seconds
                </script>
            </body>
            </html>
            `.trim();

            await writeFile(htmlFilePath, htmlContent, 'utf8'); // This line now has htmlFilePath defined
            */

            console.log('\x1b[32mCustom syntax has been transpiled into efficient JS\x1b[0m');
        } catch (err) {
            console.error('\x1b[31mFailed to return transpiled output:\x1b[0m', err);
            // Crucial: Re-throw the error if it's genuinely a failure to allow higher-level error handling
            // Or, return a specific error object if that's the expected contract.
            // For now, returning an empty object to prevent the destructuring error downstream.
            return {}; // Or { transpiledJSCode: '', error: err }
        }
    }


/*
    generateStateImports() {
        return `import { $state, $derived, $effect, bind, bindText, bindAttr, bindClass, $props } from '@semantq/ql';\n\n`; // Added $props
    }

*/

}