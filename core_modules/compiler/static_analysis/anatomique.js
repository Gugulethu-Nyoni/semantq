import { writeFile, mkdir } from 'node:fs/promises';
import { join, basename } from 'node:path';
import escodegen from 'escodegen';
import { parse } from 'acorn';
import * as estraverse from 'estraverse'; // Import estraverse

// Helper for deep cloning an AST node (needed because we'll modify it)
function deepCloneAstNode(node) {
    // A simple JSON parse/stringify is usually sufficient for most ASTs
    // generated by Acorn, as long as they don't contain circular references
    // or non-JSON-serializable properties (like functions).
    return JSON.parse(JSON.stringify(node));
}

// Recursive AST transformation function
// This function will walk the AST and replace any reactive variable identifier
// with a MemberExpression that accesses its `.value` property.
function transformReactiveIdentifiersInExpression(node, isReactiveVariableFn) {
    if (!node || typeof node !== 'object' || !node.type) {
        return node;
    }

    // Process the current node
    if (node.type === 'Identifier' && isReactiveVariableFn(node.name)) {
        // If this identifier is a reactive variable, transform it to `identifier.value`
        // Ensure it's not already part of a '.value' access (though unlikely if it's a bare Identifier)
        return {
            type: 'MemberExpression',
            object: deepCloneAstNode(node), // The original identifier becomes the object
            property: { type: 'Identifier', name: 'value' },
            computed: false,
            optional: false
        };
    }

    // Recursively process children of the current node
    for (const key in node) {
        if (node.hasOwnProperty(key) && key !== 'loc' && key !== 'range' && key !== 'comments' && key !== 'tokens') {
            const value = node[key];
            if (Array.isArray(value)) {
                node[key] = value.map(item => transformReactiveIdentifiersInExpression(item, isReactiveVariableFn));
            } else if (typeof value === 'object' && value !== null) {
                node[key] = transformReactiveIdentifiersInExpression(value, isReactiveVariableFn);
            }
        }
    }
    return node;
}


export default class Anatomique {
    constructor(jsAST, cssAST, customAST, filePath, mainPageOriginalJS = null) {
        this.filePath = filePath;
        //this.mainPageOriginalJS = mainPageOriginalJS;
        this.fileName = basename(filePath, '.ast');
        this.appRootId = 'app';
        this.jsAST = jsAST;
        this.cssAST = cssAST;
        this.customAST = customAST;
        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.transpiledHTML = '';
        this.distDir = './dist';
        this.addState = true;


        this.reactiveVariables = new Set();
        this.staticVariables = new Set();
        this.onMountCallbacks = [];
        this.mainPageOriginalJS = '';
        this.derivedDeclarations = [];





        this.globalDerivedCache = new Map(); // Map: expressionString -> varName
        this.globalDerivedDeclarations = []; // Array of actual 'const varName = $derived(...);' strings

        this.localDerivedDeclarations = null; // A temporary array for block-local deriveds


        //this.analyzeJsAST(); // Populate `this.reactiveVariables` and `this.staticVariables`
        this.analyzeAndFilterJsAST();
        
        this.nodeToTranspilerMap = {
            Element: this.Element.bind(this),
            KeyValueAttribute: this.Attribute.bind(this),
            BooleanAttribute: this.Attribute.bind(this),
            EventHandler: this.Attribute.bind(this),
            TwoWayBindingAttribute: this.Attribute.bind(this),
            MustacheAttribute: this.Attribute.bind(this),
            BooleanIdentifierAttribute: this.Attribute.bind(this),
            Fragment: this.Fragment.bind(this),
            TextNode: this.TextNode.bind(this),
            MustacheTag: this.MustacheTag.bind(this),
            IfStatement: this.IfStatement.bind(this),
            EachStatement: this.EachStatement.bind(this),

        };

        //this.transpiledJSContent.push(`const appRoot = document.getElementById('${this.appRootId}');\n`);

        this.traverse();

        //this.output();
    }

    // --- Utility Methods ---

   analyzeNode(astNode) {
        if (!astNode) return;
        estraverse.traverse(astNode, {
            enter: (node) => {
                if (node.type === 'VariableDeclarator') {
                    const varName = node.id.name;
                    if (node.init?.type === 'CallExpression') {
                        const calleeName = node.init.callee?.name;
                        if (calleeName === '$state' || calleeName === '$derived' || calleeName === '$props') {
                            this.reactiveVariables.add(varName);
                            this.staticVariables.delete(varName);
                        } else {
                            if (!this.reactiveVariables.has(varName)) {
                                this.staticVariables.add(varName);
                            }
                        }
                    } else if (node.id.type === 'Identifier') {
                        if (!this.reactiveVariables.has(varName)) {
                            this.staticVariables.add(varName);
                        }
                    }
                }
            }
        });
    }


    analyzeAndFilterJsAST() {
    if (!this.jsAST || !this.jsAST.content) {
        return;
    }

    const filteredBody = [];
    estraverse.traverse(this.jsAST.content, {
        enter: (node, parent) => {
            // Analyze all top-level variable declarations, even inside onMount for now
            if (node.type === 'VariableDeclarator') {
                const varName = node.id.name;
                if (node.init?.type === 'CallExpression') {
                    const calleeName = node.init.callee?.name;
                    if (calleeName === '$state' || calleeName === '$derived' || calleeName === '$props') {
                        this.reactiveVariables.add(varName);
                        this.staticVariables.delete(varName);
                    } else {
                        if (!this.reactiveVariables.has(varName)) {
                            this.staticVariables.add(varName);
                        }
                    }
                } else if (node.id.type === 'Identifier') {
                    if (!this.reactiveVariables.has(varName)) {
                        this.staticVariables.add(varName);
                    }
                }
            }

            // Identify and extract $onMount calls
            if (node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount') {
                const onMountFunction = node.expression.arguments[0];
                if (onMountFunction && (onMountFunction.type === 'ArrowFunctionExpression' || onMountFunction.type === 'FunctionExpression')) {
                    const functionBody = onMountFunction.body;

                    if (functionBody.type === 'BlockStatement') {
                        this.onMountCallbacks.push(...functionBody.body);
                    } else {
                        this.onMountCallbacks.push(functionBody);
                    }
                }
                return estraverse.VisitorOption.Skip; // Skip this node for the main body
            }
        },
        leave: (node, parent) => {
            // This is the updated condition to also exclude ImportDeclarations
            if (parent?.type === 'Program' && node.type !== 'ImportDeclaration' && !(node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount')) {
                filteredBody.push(node);
            }
        }
    });

    // Store the filtered AST and generate the clean JS string
    this.jsAST.content.body = filteredBody;
    this.mainPageOriginalJS = escodegen.generate(this.jsAST.content);
}


    analyzeJsAST() {
        if (!this.jsAST || !this.jsAST.content) {
            return;
        }

        const filteredBody = [];
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                // If it's a top-level VariableDeclaration, analyze it immediately
                if (parent?.type === 'Program' && node.type === 'VariableDeclaration') {
                    this.analyzeNode(node);
                    filteredBody.push(node);
                    return estraverse.VisitorOption.Skip; // Skip traversal of its children
                }

                // Logic to identify and extract $onMount calls
                if (node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount') {
                    const onMountFunction = node.expression.arguments[0];
                    if (onMountFunction && (onMountFunction.type === 'ArrowFunctionExpression' || onMountFunction.type === 'FunctionExpression')) {
                        const functionBody = onMountFunction.body;

                        // NEW: Analyze the variables inside the onMount block
                        this.analyzeNode(functionBody);

                        // Store the function body as a single BlockStatement node
                        if (functionBody.type === 'BlockStatement') {
                            this.onMountCallbacks.push(...functionBody.body);
                        } else {
                            this.onMountCallbacks.push(functionBody);
                        }
                    }
                    // Skip this node so it doesn't get added to the filteredBody
                    return estraverse.VisitorOption.Skip;
                }
            },
            leave: (node, parent) => {
                // Only push nodes to filteredBody if they are top-level and haven't been skipped
                if (parent?.type === 'Program' && !node.onMountHandled) {
                    filteredBody.push(node);
                }
            }
        });

        this.jsAST.content.body = filteredBody;
        console.log("REACTIVE VARS", this.reactiveVariables);
        console.log("STATIC VARS", this.staticVariables);
        console.log("onMountCallbacks", JSON.stringify(this.onMountCallbacks,null,2));
    }


     // NEW: Method to generate the filtered JS string
    generateMainPageOriginalJS() {
        if (!this.jsAST || !this.jsAST.content) {
            this.mainPageOriginalJS = '';
            return;
        }

        // Create a deep clone to avoid modifying the original AST
        const clonedAST = deepCloneAstNode(this.jsAST.content);

        // Filter out the onMount calls from the AST
        const nonOnMountAST = estraverse.replace(clonedAST, {
            enter(node) {
                if (node.type === 'ExpressionStatement' && node.expression?.type === 'CallExpression' && node.expression.callee?.name === '$onMount') {
                    // Remove the node by returning null
                    return this.remove();
                }
            }
        });

        // Generate the code string from the filtered AST
        this.mainPageOriginalJS = escodegen.generate(nonOnMountAST);
    }



    isReactiveVariable(varName) {
        return this.reactiveVariables.has(varName);
    }

    getUniqueId(prefix = '') {
        return `${prefix}${Math.random().toString(36).slice(2, 8)}`;
    }

    // --- Helper to get/create a derived variable ---
    getOrCreateDerived(expressionCode, context = {}) {
        // If the expression contains a loop variable, we must generate a new derived
        // every time and cannot use the global cache.
        const isLoopItemInExpression = context.itemVar && expressionCode.includes(context.itemVar);
        const isGlobalScope = !this.localDerivedDeclarations;

        if (isGlobalScope && !isLoopItemInExpression && this.globalDerivedCache.has(expressionCode)) {
            return this.globalDerivedCache.get(expressionCode);
        }

        let transformedExpressionCode;
        try {
            // Parse the expression into its own mini-AST
            // Add debug log for parsing derived expressions
            //console.log(`DEBUG: getOrCreateDerived - Parsing expression: (${expressionCode})`);
            const parsedProgram = parse(`(${expressionCode})`, { ecmaVersion: 2020 });
            const expressionAst = parsedProgram.body[0].expression;
            // Apply the transformation using our `isReactiveVariable` checker
            const transformedAst = transformReactiveIdentifiersInExpression(expressionAst, (name) => this.isReactiveVariable(name));
            transformedExpressionCode = escodegen.generate(transformedAst);
        } catch (e) {
            console.error(`Error parsing or transforming derived expression "${expressionCode}":`, e);
            transformedExpressionCode = expressionCode; // Fallback to original code
        }

        const derivedVarName = this.getUniqueId('derived_');
        const derivedDeclaration = `const ${derivedVarName} = $derived(() => ${transformedExpressionCode});`;

        if (isGlobalScope) {
            this.globalDerivedCache.set(expressionCode, derivedVarName);
            this.globalDerivedDeclarations.push(derivedDeclaration);
        } else {
            // Store in the local block's declarations
            this.localDerivedDeclarations.push(derivedDeclaration);
        }

        return derivedVarName;
    }


    // --- Traversal Method ---
            traverse() {
            // The AST is now just the Fragment node.
            // Assign the AST directly to the variable.
            const htmlFragment = this.customAST;

            // We can now access the children directly from the htmlFragment.
            if (!htmlFragment || !Array.isArray(htmlFragment.children)) {
                console.warn("AST fragment or its children not found or not an array. No HTML to transpile.");
                return;
            }

            // Now, find the 'customSyntax' node within the fragment's children.
            const customSyntaxNode = htmlFragment.children.find(
                child => child.type === 'Element' && child.name === 'customSyntax'
            );

            if (!customSyntaxNode) {
                console.error("Custom syntax wrapper element 'customSyntax' not found. Cannot transpile HTML.");
                return;
            }

            if (!Array.isArray(customSyntaxNode.children)) {
                console.error("Custom syntax wrapper element 'customSyntax' has no children or children is not an array. Cannot transpile.");
                return;
            }

           // console.log("DEBUG: traverse - Found 'customSyntax' element with children. Starting transpilation block.");
            
            // Now you can traverse the children of the customSyntax node.
            this.transpileBlock(customSyntaxNode.children, { parentVar: 'appRoot' });
        }



    transpileBlock(blockNodes, context) {
        // --- FIX: Ensure blockNodes is iterable ---
        // This is the primary fix for `TypeError: blockNodes is not iterable`.
        // If blockNodes is null/undefined/not an array, it defaults to an empty array.
        const nodesToTranspile = Array.isArray(blockNodes) ? blockNodes : [];

        // Add debug log for transpileBlock
        ////console.log(`DEBUG: transpileBlock - Processing ${nodesToTranspile.length} nodes for parent: ${context.parentVar}`);

        for (const child of nodesToTranspile) {
            // Skip comments
            if (child.type === 'CommentBlock') {
                ////console.log(`DEBUG: transpileBlock - Skipping CommentBlock.`);
                continue;
            }

            const transpileFn = this.nodeToTranspilerMap[child.type];
            if (transpileFn) {
                ////console.log(`DEBUG: transpileBlock - Transpiling node type: ${child.type}`);
                transpileFn(child, context.parentVar, context);
            } else {
                console.warn(`No transpiler function found for node type: ${child.type} within a block. Node:`, child);
            }
        }
    }


    // --- Node Transpilation Methods ---

    Element(node, parentVar, context = {}) {
        const varName = `${node.name}_elem_${this.getUniqueId()}`;
        //console.log(`DEBUG: Element - Creating element ${node.name} with var ${varName}`);

        this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (Array.isArray(node.attributes)) {
            //console.log(`DEBUG: Element - Processing ${node.attributes.length} attributes for ${varName}.`);
            for (const attr of node.attributes) {
                const transpileFn = this.nodeToTranspilerMap[attr.type];
                if (transpileFn) transpileFn(attr, varName, context);
            }
        }

        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if an element has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: varName });
    }

    Fragment(node, parentVar, context = {}) {
        ////console.log(`DEBUG: Fragment - Transpiling fragment.`);
        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if a fragment has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: parentVar });
    }

    Attribute(attr, elementVarName, context = {}) {
        ////console.log(`DEBUG: Attribute - Processing attribute type: ${attr.type} for element ${elementVarName}`);
        switch (attr.type) {
            case "KeyValueAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value?.[0]?.data || "";
                this.transpiledJSContent.push(`${elementVarName}.setAttribute("${attrName}", ${JSON.stringify(attrValue)});`);
                break;
            }

            case "TwoWayBindingAttribute": {
                const bindVarName = attr.expression?.name; // Assumes simple Identifier for binding

                if (!bindVarName) {
                    console.error(`ERROR: Two-way binding: Missing variable name for ${attr.name} on element ${elementVarName}.`);
                    return;
                }

                if (!this.isReactiveVariable(bindVarName)) {
                    console.error(
                        `ERROR: Two-way binding (bind:${attr.name}) can only be used with reactive variables ` +
                        `(declared with $state()). '${bindVarName}' is not a reactive variable.`
                    );
                    return;
                }
                this.transpiledJSContent.push(`bind(${elementVarName}, ${bindVarName});`);
                break;
            }

            case "MustacheAttribute": {
                const expression = attr.expression;
                if (!expression) {
                    console.error("MustacheAttribute: Missing expression");
                    return;
                }

                // Check if this is a static string variable (like boolAttr = 'disabled')
                if (expression.type === 'Identifier') {
                    const varName = expression.name;
                    const varDecl = this.findVariableDeclaration(varName);

                    // If it's a const declaration with a string literal value
                    if (varDecl && varDecl.kind === 'const' &&
                        varDecl.init && varDecl.init.type === 'Literal' &&
                        typeof varDecl.init.value === 'string') {

                        // Directly use the static string value
                        this.transpiledJSContent.push(
                            `${elementVarName}.setAttribute("${varDecl.init.value}", "");`
                        );
                        break;
                    }
                }

                // Fallback to reactive handling for dynamic values
                const dynValueCode = escodegen.generate(expression);
                const derivedAttrValueVar = this.getOrCreateDerived(dynValueCode, context);

                if (!attr.name) {
                    // Boolean attribute spread
                    this.transpiledJSContent.push(
                        `if (${derivedAttrValueVar}.value) {`,
                        `  ${elementVarName}.setAttribute(${derivedAttrValueVar}.value, '');`,
                        `} else {`,
                        `  ${elementVarName}.removeAttribute(${derivedAttrValueVar}.value);`,
                        `}`
                    );
                } else {
                    // Regular mustache attribute
                    this.transpiledJSContent.push(
                        `bindAttr(${elementVarName}, "${attr.name}", () => ${derivedAttrValueVar}.value);`
                    );
                }
                break;
            }


            case "EventHandler": {
                const eventName = attr.name;
                const eventHandlerExpression = attr.expression; // This is the AST node for the expression

                if (!eventHandlerExpression) {
                    console.error("EventHandler: Missing expression for", eventName);
                    return;
                }

                // --- Start of FIX for FunctionExpression params ---
                // Deep clone the expression to avoid modifying the original AST unnecessarily
                const clonedExpression = deepCloneAstNode(eventHandlerExpression);

                // If it's an ArrowFunctionExpression or FunctionExpression and params is null/undefined, set it to an empty array
                if ((clonedExpression.type === 'ArrowFunctionExpression' || clonedExpression.type === 'FunctionExpression') && !clonedExpression.params) {
                    clonedExpression.params = [];
                }
                // --- End of FIX ---

                // Now, transform reactive variables within the (potentially fixed) expression
                const transformedInternalExpression = transformReactiveIdentifiersInExpression(
                    clonedExpression, // Use the cloned and potentially fixed expression
                    (name) => this.isReactiveVariable(name)
                );

                // Generate the code for the (potentially transformed) expression
                const internalHandlerCode = escodegen.generate(transformedInternalExpression);

                let finalHandlerCode;

                if (eventHandlerExpression.type === 'ArrowFunctionExpression' ||
                    eventHandlerExpression.type === 'FunctionExpression') {
                    finalHandlerCode = internalHandlerCode;
                } else if (eventHandlerExpression.type === 'Identifier') {
                    finalHandlerCode = internalHandlerCode;
                } else {
                    finalHandlerCode = `() => { ${internalHandlerCode}; }`;
                }

                this.transpiledJSContent.push(`${elementVarName}.addEventListener("${eventName}", ${finalHandlerCode});`);
                break;
            }



            case "BooleanAttribute":
            case "BooleanIdentifierAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value; // This could be a string (e.g., "true", "false", or var name) or AST node

                // If it's a static boolean like `disabled="true"` or `disabled`
                if (typeof attrValue === 'string' && (attrValue === 'true' || attrValue === 'false' || attrValue === '')) {
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${attrValue === '' ? 'true' : attrValue});`);
                }
                // If it's an expression like `disabled={isAdmin}` or `disabled={someBooleanVar}`
                else if (attr.expression) { // This handles cases like `disabled={expression}`
                    const conditionCode = escodegen.generate(attr.expression);
                    const derivedCondition = this.getOrCreateDerived(conditionCode, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                // Fallback for simple identifier attributes like `disabled={myReactiveVar}` directly on attr.value
                else if (typeof attrValue === 'string' && this.isReactiveVariable(attrValue)) {
                    const derivedCondition = this.getOrCreateDerived(attrValue, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                else {
                    // Fallback for any other type (e.g., if it was a plain non-reactive `let myBool = true;`)
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${!!attrValue});`);
                }
                break;
            }

            default:
                this.transpiledJSContent.push(`// Unknown attribute type: ${attr.type}`);
        }
    }

    TextNode(node, parentVar) {
        const varName = `text_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: TextNode - Creating text node with var ${varName} and value "${node.value}"`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode(${JSON.stringify(node.value)});`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
    }

    MustacheTag(node, parentVar, context = {}) {
        const varName = `mustache_node_${this.getUniqueId()}`;
        //console.log(`DEBUG: MustacheTag - Creating mustache node with var ${varName}`);
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode('');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (!node.expression) {
            console.error("MustacheTag: Missing expression");
            return;
        }

        let expressionCode = escodegen.generate(node.expression);

        // Check if the expression is the loop item variable itself
        // This is a specific edge case / helper, might need adjustment based on desired behavior
        if (context.itemVar && expressionCode === context.itemVar) {
            console.warn(`Implicitly accessing "${context.itemVar}.name" in an #each block. It's better to be explicit: {${context.itemVar}.name}`);
            expressionCode = `${context.itemVar}.name`; // Or handle as an error if explicit is mandatory
        }

        const derivedVar = this.getOrCreateDerived(expressionCode, context);
        this.transpiledJSContent.push(`bindText(${varName}, ${derivedVar});`);
    }


    findVariableDeclaration(varName) {
        let declaration = null;
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                if (node.type === 'VariableDeclarator' &&
                    node.id.type === 'Identifier' &&
                    node.id.name === varName) {
                    declaration = {
                        kind: parent?.kind, // Using optional chaining
                        init: node.init
                    };
                    return estraverse.VisitorOption.Break; // Correct way to stop traversal
                }
            }
        });
        return declaration;
    }




    EachStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const sourceCode = escodegen.generate(node.source);
        const itemVar = node.item.name;
        const keyVar = node.key ? node.key.name : null;

        //console.log(`DEBUG: EachStatement - Processing #each block for source: ${sourceCode}, item: ${itemVar}`);

        // 1. Create DOM structure
        const fragmentPlaceholder = `each_placeholder_${id}`;
        const eachItemsVar = `each_items_${id}`;
        const cleanupsVar = `each_cleanups_${id}`;

        this.transpiledJSContent.push(
            `const ${fragmentPlaceholder} = document.createComment('each block');`,
            `${parentVar}.appendChild(${fragmentPlaceholder});`,
            `let ${eachItemsVar} = [];`,
            `let ${cleanupsVar} = [];`
        );

        // 2. Temporarily store and transpile the block body
        // Ensure node.body.body is an array, as `transpileBlockContent` expects it.
        const bodyNodes = Array.isArray(node.body?.body) ? node.body.body : [];
        const itemBlockData = this.transpileBlockContent(bodyNodes, { ...context, itemVar: itemVar, keyVar: keyVar });

        // 3. Generate the render function for a single item, including its local deriveds
        this.transpiledJSContent.push(
            `const render_each_item_${id} = (${itemVar}) => {`,
            ` const ${itemBlockData.fragmentVar} = document.createDocumentFragment();`,
            ` ${itemBlockData.blockDeriveds}`,
            ` ${itemBlockData.blockJS}`,
            ` return { nodes: Array.from(${itemBlockData.fragmentVar}.childNodes), cleanups: [${itemBlockData.blockCleanups}] };`,
            `};`
        );

        // 4. Create the reactive effect that re-renders the list
        this.transpiledJSContent.push(
            `$effect(() => {`,
            ` ${cleanupsVar}.forEach(fn => fn());`,
            ` ${cleanupsVar}.length = 0;`,
            ` ${eachItemsVar}.forEach(el => el.remove());`,
            ` ${eachItemsVar}.length = 0;`,
            ` const sourceArray = ${this.getOrCreateDerived(sourceCode, context)}.value ?? [];`, // <-- MODIFIED: Access .value of derived source array
            ` sourceArray.forEach((${itemVar}, index) => {`,
            `  const itemData = render_each_item_${id}(${itemVar});`,
            `  ${fragmentPlaceholder}.after(...itemData.nodes);`,
            `  ${eachItemsVar}.push(...itemData.nodes);`,
            `  ${cleanupsVar}.push(...itemData.cleanups);`,
            ` });`,
            `});`
        );
    }


    IfStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const placeholderCommentVar = `if_placeholder_${id}`;

        //console.log(`DEBUG: IfStatement - Processing #if block.`);

        // The condition for the if statement. Use getOrCreateDerived for the condition itself.
        const conditionCode = escodegen.generate(node.test);
        const derivedConditionVar = this.getOrCreateDerived(conditionCode, context);

        this.transpiledJSContent.push(`const ${placeholderCommentVar} = document.createComment('if block');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${placeholderCommentVar});`);

        // --- FIX: Ensure node.consequent.body is an array ---
        const consequentNodes = Array.isArray(node.consequent?.body) ? node.consequent.body : [];
        const ifBranchData = this.transpileBlockContent(consequentNodes, context);
        const createIfFragmentFunction = `create_if_fragment_${id}`;

        this.transpiledJSContent.push(`const ${createIfFragmentFunction} = () => {`);
        this.transpiledJSContent.push(` const ${ifBranchData.fragmentVar} = document.createDocumentFragment();`);
        this.transpiledJSContent.push(ifBranchData.blockDeriveds);
        this.transpiledJSContent.push(ifBranchData.blockJS);
        this.transpiledJSContent.push(` return {`);
        this.transpiledJSContent.push(`  nodes: Array.from(${ifBranchData.fragmentVar}.childNodes),`);
        this.transpiledJSContent.push(`  cleanups: () => { ${ifBranchData.blockCleanups} }`);
        this.transpiledJSContent.push(` };`);
        this.transpiledJSContent.push(`};`);

        let createElseFragmentFunction = null;
        if (node.alternate) {
            // --- FIX: Ensure node.alternate.body is an array ---
            const alternateNodes = Array.isArray(node.alternate?.body) ? node.alternate.body : [];
            const elseBranchData = this.transpileBlockContent(alternateNodes, context);
            createElseFragmentFunction = `create_else_fragment_${id}`;

            this.transpiledJSContent.push(`const ${createElseFragmentFunction} = () => {`);
            this.transpiledJSContent.push(` const ${elseBranchData.fragmentVar} = document.createDocumentFragment();`);
            this.transpiledJSContent.push(elseBranchData.blockDeriveds);
            this.transpiledJSContent.push(elseBranchData.blockJS);
            this.transpiledJSContent.push(` return {`);
            this.transpiledJSContent.push(`  nodes: Array.from(${elseBranchData.fragmentVar}.childNodes),`);
            this.transpiledJSContent.push(`  cleanups: () => { ${elseBranchData.blockCleanups} }`);
            this.transpiledJSContent.push(` };`);
            this.transpiledJSContent.push(`};`);
        }

        this.transpiledJSContent.push(`let if_elements_${id} = [];`);
        this.transpiledJSContent.push(`let if_element_cleanups_${id} = [];`);

        this.transpiledJSContent.push(`$effect(() => {`);
        this.transpiledJSContent.push(` // Run previous cleanups (if any)`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.forEach(fn => fn());`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.length = 0;`);

        this.transpiledJSContent.push(` // Remove previous elements from DOM`);
        this.transpiledJSContent.push(` if_elements_${id}.forEach(el => el.remove());`);
        this.transpiledJSContent.push(` if_elements_${id}.length = 0;`);

        this.transpiledJSContent.push(` let fragmentData;`);
        this.transpiledJSContent.push(` if (${derivedConditionVar}.value) {`); // Access value of derived condition
        this.transpiledJSContent.push(`  fragmentData = ${createIfFragmentFunction}();`);
        this.transpiledJSContent.push(` } `);

        if (createElseFragmentFunction) {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = ${createElseFragmentFunction}();`);
            this.transpiledJSContent.push(` }`);
        } else {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = null;`); // Explicitly set to null if no else branch
            this.transpiledJSContent.push(` }`);
        }

        this.transpiledJSContent.push(` if (fragmentData) {`);
        this.transpiledJSContent.push(`  ${placeholderCommentVar}.after(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_elements_${id}.push(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_element_cleanups_${id}.push(fragmentData.cleanups);`);
        // --- FIX: Corrected typo `this.transpiledJSContent.transpiledJSContent.push` to `this.transpiledJSContent.push` ---
        this.transpiledJSContent.push(` }`);
        this.transpiledJSContent.push(`});`);
    }


    // This helper function is used by IfStatement and EachStatement to create a self-contained block
    transpileBlockContent(blockNodes, context = {}) {
        const originalTranspiledContent = this.transpiledJSContent;
        const originalComponentCleanups = this.componentCleanups;
        const originalLocalDeriveds = this.localDerivedDeclarations;

        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.localDerivedDeclarations = [];

        const fragmentVar = `fragmentRoot_${this.getUniqueId()}`;
        ////console.log(`DEBUG: transpileBlockContent - Starting new block context for fragment ${fragmentVar}`);

        // --- FIX: Ensure blockNodes is an array before passing to transpileBlock ---
        // This makes `transpileBlockContent` robust to cases where `blockNodes` might not be an array.
        this.transpileBlock(Array.isArray(blockNodes) ? blockNodes : [], { ...context, parentVar: fragmentVar });

        const blockJS = this.transpiledJSContent.join('\n');
        const blockCleanups = this.componentCleanups.join('\n');
        const blockDeriveds = this.localDerivedDeclarations.join('\n');

        this.transpiledJSContent = originalTranspiledContent;
        this.componentCleanups = originalComponentCleanups;
        this.localDerivedDeclarations = originalLocalDeriveds;

        ////console.log(`DEBUG: transpileBlockContent - Finishing block context for fragment ${fragmentVar}`);

        return {
            blockJS,
            blockCleanups,
            blockDeriveds,
            fragmentVar
        };
    }

    

    // --- Output Generation ---

async output() {
    try {
        const mainComponentJS = this.transpiledJSContent.join('\n');
        const mainComponentCleanups = this.componentCleanups.join('\n');
        const generatedDerivedDeclarations = this.globalDerivedDeclarations.join('\n');
        
        // Process onMount callbacks
        const onMountEffects = this.onMountCallbacks.map((callback) => {
            const code = escodegen.generate(callback);
            return `
                $effect(() => {
                    let cleanupFn;
                    const mount = () => {
                        try {
                            ${code}
                            
                            // Auto-detect cleanup
                            if (typeof ${callback.id} === 'object' && ${callback.id} !== null) {
                                if (typeof ${callback.id}.destroy === 'function') {
                                    cleanupFn = () => ${callback.id}.destroy();
                                } else if (typeof ${callback.id}.dispose === 'function') {
                                    cleanupFn = () => ${callback.id}.dispose();
                                }
                            }
                        } catch (e) {
                            console.error('Mount error:', e);
                        }
                    };
                    
                    // Double RAF for reliable mounting
                    let rafId;
                    const scheduleMount = () => {
                        cancelAnimationFrame(rafId);
                        rafId = requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                mount();
                            });
                        });
                    };
                    
                    scheduleMount();
                    
                    return () => {
                        cancelAnimationFrame(rafId);
                        if (cleanupFn) cleanupFn();
                    };
                });
            `;
        }).join('\n');

        const finalJsCode = `
${this.mainPageOriginalJS}

${generatedDerivedDeclarations}

export function renderComponent(targetElement) {
    const appRoot = targetElement || document.getElementById("app");
    
    if (!appRoot) {
        console.error("App root element not found");
        return () => {};
    }

    ${mainComponentJS}
    
    ${onMountEffects}

    return () => {
        ${mainComponentCleanups}
        while (appRoot.firstChild) {
            appRoot.removeChild(appRoot.firstChild);
        }
    };
}
`.trim();

        return { transpiledJSCode: finalJsCode };
    } catch (err) {
        console.error('Failed to generate output:', err);
        return {};
    }
}
/*
    generateStateImports() {
        return `import { $state, $derived, $effect, bind, bindText, bindAttr, bindClass, $props } from '@semantq/ql';\n\n`; // Added $props
    }

*/

}